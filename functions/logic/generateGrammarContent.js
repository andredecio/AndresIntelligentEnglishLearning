const functions = require("firebase-functions/v1");
const admin = require("firebase-admin");
const { getTextGenModel } = require("../helpers/gemini");
const { normalizeTitle, generateUniqueFirestoreId } = require("../helpers/ipaUtils"); // adjust path if needed

// --- generateGrammarContent Callable Function ---
// This function is called from your AdminSystem webpage to generate new grammar content using Gemini.
const generateGrammarContent = functions.region('asia-southeast1').runWith({ timeoutSeconds: 540 }).https.onCall(async (data, context) => {
    // --- Security Check (Crucial for Admin Functions) ---
    if (!context.auth) {
        throw new functions.https.HttpsError('unauthenticated', 'The function must be called while authenticated.');
    }
    if (!context.auth.token.admin) {
        throw new functions.https.HttpsError('permission-denied', 'Only authorized administrators can perform this action.');
    }
    // --- End Security Check ---

    const { cefrLevel, numItems, theme } = data;

    if (!cefrLevel || !numItems || !theme || numItems <= 0) {
        throw new functions.https.HttpsError(
            'invalid-argument',
            'CEFR Level, Number of Words, and Theme are required and must be valid.'
        );
    }

    functions.logger.info(`AdminSystem: Starting grammar content generation for CEFR: ${cefrLevel}, Items: ${numItems}, Theme: ${theme}`);

    const textGenModel = getTextGenModel(); // Get the Gemini text generation model instance
    const firestore = admin.firestore(); 
    const batch = firestore.batch();
    const createdModuleIds = [];
    let numSkipped = 0;
	const skippedWords = [];
	let geminiReturnedItemCount = 0;
    let topLevelGrammarCount = 0;
    let GrammarGroupCount = 0;
    try {
        // --- 1. Construct the sophisticated prompt for Gemini ---
        const geminiPrompt = `
        Generate a JSON array of ${numItems} grammar teaching items for CEFR ${cefrLevel} level, themed around "${theme}".
        Each item in the array MUST represent a module and adhere to the following strict JSON schema and rules:

        **Primary Module Fields (all modules will have these):**
		- "MODULETYPE": String (e.g. GRAMMAR ).
        - "TITLE": String.
        - "CEFR": String (e.g., "A1", "B2").
        - "DESCRIPTION": String.
        - "THEME": String.

        **Module Types and Their Specific Fields:**

        1.  **GRAMMAR** (for individual teaching point:
            - "MODULETYPE": "GRAMMAR"
            - "TITLE": The title of the grammar point
			- "CEFR": This must be ${cefrLevel}
            - "DESCRIPTION": Must be about 3 numbered sentences (e.g., "1. Sentence one. 2. Sentence two. 3. Sentence three.") that explain the grammar teaching point
            - "THEME":This must be ${theme}
			- "imagePrompt": String. A concise, descriptive instruction for an AI image generator to create an image based on the grammar teaching point(s) in the DESCRIPTION field. 

        **Crucial Rules for Generation:**
		- **MODULETYPE:** You MUST create a unique GRAMMAR MODULETYPE document for EACH distinct grammar teaching point. For example 'ed' is the common ending for the Past Participle form of regular verbs.      
		- **CEFR Hierarchy:** For All GRAMMAR modules, their 'CEFR' level MUST be used to decide on the grammar teaching point degree of sophistication.
        - **Output Format:** Provide ONLY the JSON array. Do not include any introductory or concluding text.
        - **No IDs/URLs:** Do NOT include "MODULEID" or "IMAGEURL" fields in your output. These will be generated by the Cloud Function.
        - **Number of Items:** Aim to generate exactly ${numItems} top-level GRAMMAR items, each with a unique grammar teaching point
        - **TITLE:** This field must contain the title of the grammar teaching point exclusively.
		
		Example structure for output (simplified, real output will have more fields per module as per rules):
        [
          {
            "TITLE": "Regular Verbs",
            "MODULETYPE": "GRAMMAR",
            "CEFR": "A2",
            "DESCRIPTION": "1. Regular verbs end with 'ed' for the Perfect Tenses. 2. Regular verbs end with 'ed' for the Simple Past Tense too. 3. We met in the restaurant but he HAD FINISHED his meal already",
            "THEME": "Verb Rules",
			"imagePrompt": "A young woman meeting a man in a restaurant, showing an empty plate infront of him."
          },
          {
            "TITLE": "'-ed' at the end of a word", 
			"MODULETYPE": "GRAMMAR",
            "CEFR": "A2",
            "DESCRIPTION": "1. When the letter before '-ed' is VOICED (you make a sound in your voicebox) then it's pronounced 'd'. 2. When the letter before '-ed' is NONVOICED (you make no sound in your voicebox) then it's pronounced 't'. 3.When the letter before '-ed' is either 't' or 'd' then it's pronounced 'id'.",
            "THEME": "Pronunciation",
			"imagePrompt": "An image of the suffix 'ed' in bold."
			},
          {
            "TITLE": "He/She/It for Present Simple verbs",
            "MODULETYPE": "GRAMMAR",
            "CEFR": "A1",
            "DESCRIPTION": "1. The Present Simple form of the verb must end with 's' or 'es' 2. He walks to school everyday. 3. She washes her hair every week",
            "THEME": "Third Person Singular",
			"imagePrompt": "A young woman washing her hair"
		  },
			
			]
        `; // This closes the backtick for the geminiPrompt multiline string.

        const result = await textGenModel.generateContent(geminiPrompt);
        const response = await result.response;
        const rawText = await response.text();


// Clean & parse
const cleanedText = rawText
  .trim()
  .replace(/^```json/, '')
  .replace(/```$/, '')
  .replace(/\s*}+\s*$/, ']');  // Fix Gemini's trailing brace issue
		
		functions.logger.info(`Cleaned text from Gemini. Length: ${cleanedText.length}`);
        functions.logger.info(`Cleaned text (first 500 chars): ${cleanedText.substring(0, 500)}`);
        functions.logger.info(`Cleaned text (last 500 chars): ${cleanedText.length > 500 ? cleanedText.substring(cleanedText.length - 500) : cleanedText}`);


        let generatedContent;
        try {
            generatedContent = JSON.parse(cleanedText);
			geminiReturnedItemCount = generatedContent.length; //  SET THE COUNT HERE 
            functions.logger.info(`Gemini returned ${geminiReturnedItemCount} top-level JSON items.`);
	   } catch (e) {
  functions.logger.error("Failed to parse Gemini JSON:", cleanedText);
  throw new Error("Failed to parse Gemini output as JSON: " + e.message);
        }

        // --- 2. Process Generated Content and Write to Firestore (with Deduplication) ---
        for (const item of generatedContent) {
            const itemModuleType = item.MODULETYPE || 'GRAMMAR';
            const itemNormalizedTitle = normalizeTitle(item.TITLE);

            const existingContentSnapshot = await firestore.collection('learningContent')
                .where('MODULETYPE', 'in', ['GRAMMAR'])
                .where('normalizedTitle', '==', itemNormalizedTitle)
                .limit(1)
                .get();

            if (!existingContentSnapshot.empty) {
                functions.logger.info(`Skipping "${item.TITLE}" (${itemModuleType}) as a record with this title already exists.`);
                numSkipped++;
                skippedWords.push(item.TITLE);
				continue;
            }

            // --- If the item is NOT skipped, process it and add to the Firestore batch ---
           if (itemModuleType === "GRAMMAR") {
                 topLevelGrammarCount++; 
                functions.logger.info(`Processing  GRAMMAR: "${item.TITLE}".`); 
				const grammarid = generateUniqueFirestoreId();
                const grammarRef = firestore.collection('learningContent').doc(grammarid);

                batch.set(grammarRef, {
                    MODULEID: grammarid,
                    MODULETYPE: "GRAMMAR",
                    TITLE: item.TITLE,
                    normalizedTitle: itemNormalizedTitle,
                    CEFR: item.CEFR,
                    DESCRIPTION: item.DESCRIPTION,
                    imagePrompt: item.imagePrompt,
                    THEME: item.THEME,
					IMAGEURL: "",
                    imageStatus: "pending",
                    MODULEID_ARRAY: [],
                    createdAt: admin.firestore.FieldValue.serverTimestamp(),
                    updatedAt: admin.firestore.FieldValue.serverTimestamp()
                });
                createdModuleIds.push(grammarid);

            } else {
                functions.logger.warn(`Skipping unexpected top-level module type generated by Gemini: ${itemModuleType} for item with title "${item.TITLE}".`);
            }
        } // End of for (const item of generatedContent) loop

        await batch.commit();

 functions.logger.info(`Content generation summary: Requested ${numItems}, Gemini returned ${geminiReturnedItemCount} top-level items. Processed ${topLevelGrammarCount} ). Successfully created ${createdModuleIds.length} new modules. Skipped ${numSkipped} duplicates.`);//        // --- CHANGE: Trigger batchGenerateGRAMMARImages (cleaned up and restored) ---

        return {
            status: "success",
            message: `Successfully generated and saved ${createdModuleIds.length} new modules to Firestore. Skipped ${numSkipped} duplicates.`,
            moduleIds: createdModuleIds,
			skippedWords: skippedWords,
			geminiReturnedItemCount: geminiReturnedItemCount,
            topLevelGrammarCount: topLevelGrammarCount,
            GrammarGroupCount: GrammarGroupCount,
		};

    } catch (error) {
        functions.logger.error("Error generating or saving content:", error);
        if (error instanceof functions.https.HttpsError) {
            throw error;
        }
        throw new functions.https.HttpsError('internal', 'An unexpected error occurred during content generation.', error.message);
    }
}) // This closes the exports.generateGRAMMARContent function definition

module.exports = { generateGrammarContent };

